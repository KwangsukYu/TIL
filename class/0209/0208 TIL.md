# 0209 TIL

## Class

 1. **내용 요약 및 부족한 부분**

    1. 알고리....즈..ㅁ..
    1. 한 귀로 들으려 해도 들리지가 않았따..
    
 2. **오늘 새롭게 알게 된 것**

    1.  시간 복잡도
    
       * 문제 풀때 많이 들어본 말들 중 하나인데 정확이 무슨 뜻인지 몰랐지만 수업을 들어도 몰랐다.
       * 일단 가장 큰 영향력을 준 n에 대한 항만 표시해서 빅-오 표기법으로 나타낸다
       * O(n), O(n^2), O(logn) 등등
       * 아직 이해한 개념은 for문 한번이면 n 두번이면 n^2으로 늘어난 다는 거?
       * n^2이상은 쓰면서 생각을 좀 해봐야한다는거?
    
    2.  버블 정렬
       * 첫 번째 원소부터 인접한 원소끼리 자리를 계속 교환하면서 움직인다.
    
       * 가장 큰 원소가 마지막 자리로 정렬
    
       * 교환 하는 모습이 거품과 같다고해서 버블 정렬
    
       * 시간 복잡도 O(n^2)
    
       * ```python
         for i in range(N-1, 0, -1): #배열 끝에서 시작해서
             for j in range(0, i): # 배열 끝을 하나씩 줄여나간다!
             if a[j] > a[j+1]:
                 a[j], a[j+1] = a[j+1], a[j]
         ```
    
       * 파이썬 처음에 max함수 대신 써보려고 만들었던 함수가 버블정렬이었다!!!
    
    3.  카운팅 정렬
    
       * 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 알고리즘
    
       * 정수로 표현할 수 있는 자료에 대해서만 가능
    
       * 가장 큰 정수로 배열은 만들어야하므로 그 정수를 알 필요가 있다.
    
       * 각 항목의 수를 세고 인덱스로 배열에 저장한다
    
       * 각 항목 앞에 위치할 항목의 개수를 반영하여 원소를 조정한다.
    
       * ```python
         A = [] - 입력 # 정렬 할 리스트
         B = [] - 정렬
         C = [] - 카운트 
         # 인덱스는 숫자고 값은 A에 등장한 숫자의 횟수를 갖는 리스트로 한 번 정렬하고
         # 다시 값으로 누적 횟수를 갖게 정렬해줌 > 정렬 할때 사용하기 위해
         
         C = [0] * (k+1) # 최대 정수 k의 값 0부터 시작하기 때문에 +1
         
         for i in range (0, len(A)) # 등장 횟수를 저장해줌
         	C[A[i]] += 1
         for i in range (1, len(C)) # 등장 횟수의 누적 합을 저장해줌
         	C[i] += C[i-1]
         for i in range (len(B)-1, -1, -1):
         # A랑 B랑 길이가 같을거고 뒤에서부터 집어 넣을 거라서 뒤부터?
         # B의 C에 누적합에 해당하는 인덱스에 A를 넣어주고 누적합 - 1
         # ex) 0이 3개면 3번째 인덱스에 0을 넣고 -1을 해줘서 다음에 2번째 인덱스로 감
             C[A[i]] -= 1
             B[C[A[i]]] = A[i]
         ```
    
       * 이건 무슨소린지 감이 안오는데 인덱스를 이용한다는 점
    
       * 파이썬 딕셔너리랑 비슷한 부분이 있다는 점만 느끼고있는 중...
    
    4.  완전 검색? 완전 탐색?
    
       * 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법
       * 예를 들어 4자리의 비밀번호를 풀려고 할때 1~ 9999까지 시도, 10000번 안에 해결하는 것
       * CS 알고리즘 규칙에 적절성과 효율성이 있는데 적절성만을 보고 하는 것
       * 문제에 대한 파악을 먼저하고 완전 검색을 쓸지 말지 정하자!
       * 아직은 모르겠다.
    
    5.  탐욕(greedy) 알고리즘
    
       * 최적의 답을 구하는데 사용됨
       * 여러 경우 중 그 순간 최적이라고 생각되는 것을 선택해나가는 방식
       * 최종적인 해답이 최적이라고는 볼 수 없다.
       * 일반적으로 바로 떠오르는 방법이 이 알고리즘에 해당한다.
       * 답 선택 > 가능성 검사 > 답 검사 > 답 선택 반복!!!
       * 좀 더 문제를 풀어보자!
    
    6.  배열과 for문에서 인덱스 사용으로 깔끔하게 코드를 짤 수 있다. 인덱스 활용 중요! 익숙해지기

 * **감상**
    * 첫 알고리즘을 접해보니 의식하지 않고 썼던 것들이 하나씩 보였다.
    * 하지만 너무 어렵다. 무슨소리인지 모르겠다...
    * 시간 복잡도를 보고나니 뭔가 제출 할때마다 시간을 보게 된다...
    * 문제나 열심히 풀어보자!

