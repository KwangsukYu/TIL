# 0216 TIL

## Class

 1. **내용 요약 및 부족한 부분**

    1. 문자열

    1. 패턴찾는 알고리즘

    1. 암호??

       

 2. **오늘 새롭게 알게 된 것**

    1. 문자열과 리스트 슬라이싱 차이점!

       * 리스트는 복사되어서 슬라이싱으로 처리하는데 문자열은 똑같나보다.

       ```python
       s1 = 'abc'
       s2 = 'abc'
       s3 = 'def'
       s4 = s1
       s5 = s1[:2] + 'c'
       
       print(s1 == s2) # T
       print(s1 is s2) # T
       print(s5) # abc
       print(s1 == s5) # T
       print(s1 is s5) # F id 값이 달라짐, 슬라이싱이면 새롭게 만들어지기 때문에
       #s1[:3] is s1은 똑 같음! 문자열은 같고 리스트인 경우에는 다르다!
       ```

       

    2. 고지식한 패턴 검색 (brute force)

         * 본문 문자열을 처음부터 끝까지 순회, 패턴 내의 문자들을 하나하나 비교한다.

         * ```python
           def BruteForce(p, t): #교재
               i = 0
               j = 0
               while j < M and i < N:
                   if t[i] != p[j]:
                       i = i - j
                       j = -1
                   i = i + 1
                   j = j + 1
               if j == M:
                   return i - M 
               else:
                   return False
           ```

         * 시간 복잡도 O(MN)

           

    3. KMP 알고리즘

         * 불일치가 발생한 앞부분에 대하여 다시 비교지 않고 매칭

         * 전처리 배열을 구해서 잘못된 시작을 최소화

         * 시간복잡도 O(M+N)

         * 머리로는 알겠지만 구현은 노력해야겠다.

           ```python
           def kmp(t, p):
               N = len(t)
               M = len(P)
               lps = [0] * (M+1)
               # preprocessing
               j = 0 # 일치한 개수 == 비교할 패턴 위치
               lps[0] = -1
               for i in range(1, M):
                   lps[i] = j  # p[i] 이전에 일치한 개수
                   if p[i] == p[j]:
                       j += 1
                   else:
                       j = 
               lps[M] = j
               
               while i < N and j <= M:
                   if j == -1 or t[i] == p[i]:
                       i += 1
                       j += 1
                   else:
                       j = lps[j]
                   if j == M
                   print(i - M, end = ' ')
                   j = lps[j] # 연속된 패턴 찾기?
           ```
           
           

    4. 보이어-무어 알고리즘

         * 오른쪽에서 왼쪽으로 비교

         * 대부분 상용 소프트웨어가 채택한다고한다.

         * 오른 쪽 끝에 문자가 불일치, 패턴에 없으면 이동거리는 패턴의 길이만큼

         * 패턴 내에 일치하는 문자가 있으면 그 부분에 인덱스를 맞추고 다시 검색

         * O(MN)

         * hospool 알고리즘?

           

    5. 문자열 암호화

       * 아직 건들지말자?

       * 허프만 코딩?

         

    6. 오늘 경악한 풀이법

         ```python
         #SWEA GNS 문제
         code[ord('N')][ord['I']][ord['N']] = 9
         # 128* 128* 128 배열 만듬, 아스키코드 
         count[code[ord(arr[i][0])][ord(arr[i][1])][ord(arr[i][2])]
         # 이런식으로 3차원 배열로 값을 저장해서 푸는 방법도 있었다.
         # == 연산은 파이썬만 지원한다고하더라...
         ```

         

 3. **감상**

     1. 문자열은 파이썬의 특성을 이용하면 쉽게 풀 수 있는데 다른 언어로 가면 막막해 질 것 같다.

     1. 최대한 파이써닉하게 풀지 않고 클래식으로 풀어보려고 노력해야겠다.

     1. 주석 달기는 조금씩 늘어가는 중이라 만족한다!

        

 4. **알아보기**

     * hospool 알고리즘
     * 허프만 코딩

