# 0223 TIL

## Class

 1. **내용 요약 및 부족한 부분**

    1. DFS

    1. 백트래킹

 2. **오늘 새롭게 알게 된 것**

    1. DFS(Depth-First Search)

       * 정점과 노드로 이루어진 그래프에서 깊이를 우선으로 탐색하는 방법
    
       * 후입선출의 스택구조나 재귀를 활용하여 push와 pop을 통해 찾아간다
       
       * 갈 곳이 없게되면 마지막에 갈림길로 돌아와 다시 탐색하여 모든 정점을 방문하게된다.
       
       * 알고리즘 설명
       
         * 시작 정점 V를 설정
         * 정점 V에 인접한 정점 중에서
         * 방문하지 않은 정점이 있다면 스택에 push하고 그 정점을 방문한 뒤 V로 놓고 다시 반복
         * 방문핮 ㅣ않은 정점이 없으면 스택을 pop하고 마지막 정점을 v로 하여 반복
         * 스택이 공백이 될 때 까지
       
       * 구현 순서
       
       * 초기상태 : 배열 visited를 False나 0으로 초기화, 공백 스택 생성
       
       * 주어진 노드를 인접행렬이나 인접리스트로 받기
       
         ```python
         # 정점의 갯수 V 7
         # 간선의 갯수 E 8
         # 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7, 두개 씩 잘라서 읽어야함
         
         V, E = map(int, input().split())
         arr = list(map(int, input(.split())))
         adj = [[0]*(V+1) for _ in range(V+1)] # 0포함하니 1개씩 더 만듬
         for i in range(E):
             n1, n2 = arr[i*2], arr[i*2+1]	# 한 줄로 주어질 경우의 인덱스 처리
             adj[n1][n2] = 1   # n1과 n2는 인접
             ajd[n2][n1] = 1   # 방향 표시가 없는 경우
            
         # 정점의 갯수 V 7
         # 간선의 갯수 E 8
         # 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7, 두개 씩 잘라서 읽어야함
         
         V, E = map(int, input().split())
         arr = list(map(int, input(.split())))
         adjlist = [[]for _ in range(V+1)]
         for i in range(E):
             n1, n2 = arr[i*2], arr[i*2+1]
             adjlist[n1].append(n2)
             adjlist[n2].append(n1)
         ```
       
         
       
       * 정점 A에 방문하지 않은 정점 BC에 대해서 A를 push한 후 규칙에 따라 선택하여 탐색
       
       
       
    2. 백트래킹
    
         * DFS와 비슷하나 문제를 풀어가면서 확인 중인 노드가 제한조건에 위배 되는지 (유망하지 않은지)를 판단하고 그 경우 해당 노드를 제외하고 탐색하는 방식(가지치기)
    * N-queen 문제, 체스판
         
    
 3. **감상**

     1. 처음에는 뭔소리인가 했는데 문제를 직접접해보니 어떠한 구조로 돌아가는지 이해가 됐다.
     1. 스택의 후입선출을 이용한 부분이고 이 후의 BFS도 큐의 특성을 이용한 것일듯

